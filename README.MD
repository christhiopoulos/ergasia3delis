1. Διαχωρισμός Ρόλων σε Ξεχωριστές Διεργασίες
Manager

Ο Manager αναλαμβάνει τον «συντονισμό» του συστήματος.
Δημιουργεί τη shared memory και τα named semaphores που θα χρησιμοποιήσουν τα υπόλοιπα προγράμματα, και μετά εκκινεί (fork + exec) το reception, το monitor και τους visitors.
Επίσης, σε περίπτωση σήματος SIGINT, οργανώνει τον ομαλό τερματισμό όλων των child διεργασιών.
Receptionist

Λειτουργεί ως ένας υπάλληλος υποδοχής που λαμβάνει παραγγελίες από τους visitors μέσω μιας κοινής ουράς (queue) παραγγελιών.
Μόλις διαβάσει μια παραγγελία, κάνει έναν τυχαίο «χρόνο εξυπηρέτησης», και στο τέλος ειδοποιεί τον αντίστοιχο visitor ότι η παραγγελία είναι έτοιμη.
Visitor

Παριστά τους πελάτες του μαγαζιού.
Ψάχνει διαθέσιμο τραπέζι, το «καταλαμβάνει» και στέλνει παραγγελία στον receptionist (μέσω της κοινής ουράς).
Περιμένει να ολοκληρωθεί η παραγγελία (σε έναν δικό του μοναδικό semaphore), κάθεται για λίγη ώρα (rest_time) και τελικά αποχωρεί, ενημερώνοντας τα στατιστικά.
Monitor

Διαβάζει περιοδικά την κατάσταση της κοινής μνήμης (shared memory) και εκτυπώνει πληροφορίες: την ουρά των παραγγελιών, ποιοι κάθονται σε ποια τραπέζια κ.λπ.
Τερματίζει είτε ύστερα από σήμα SIGINT, είτε (προαιρετικά) όταν manager θέσει το flag running = 0.


2. Επικοινωνία μέσω Shared Memory & Named Semaphores
Η κοινή μνήμη (shared memory) επιτρέπει σε όλες τις διεργασίες να έχουν πρόσβαση σε μια ενιαία δομή SharedData. Εκεί:

Αποθηκεύουμε την ουρά των παραγγελιών (orders[], με δείκτες head και tail).
Αποθηκεύουμε τις δομές «τραπεζιών» (tables[]), περιλαμβάνοντας για κάθε τραπέζι πόσα άτομα κάθονται και τα PID τους.
Διατηρούμε «συνολικά» στατιστικά, όπως αριθμό επισκεπτών, χρόνους αναμονής/διαμονής, πλήθος συγκεκριμένων ειδών που παρήγγειλαν κ.λπ.


SEM_MUTEX: Είναι το κλασικό «mutex» που κλειδώνει την shared memory κατά την τροποποίησή της (για αποφυγή race conditions).
SEM_ORDER_QUEUE: Είναι ένας semaphore που υποδηλώνει «υπάρχει παραγγελία στην ουρά». Κάθε φορά που ένας visitor τοποθετεί μια παραγγελία, κάνει sem_post(SEM_ORDER_QUEUE). Ο receptionist κάνει sem_wait(SEM_ORDER_QUEUE) για να γνωρίζει πότε πρέπει να εξυπηρετήσει.
Για την ειδοποίηση του εκάστοτε visitor ότι η παραγγελία του ολοκληρώθηκε, χρησιμοποιούμε έναν μοναδικό semaphore. 




3. Στρατηγική Χειρισμού «Τραπεζιών»
Καθένας από τους visitors:

Παίρνει το SEM_MUTEX.
Σαρώνει τα τραπέζια για να βρει κάποιο που δεν είναι table_full και occupied < CHAIRS_PER_TABLE.
Μόλις βρει ένα, καταλαμβάνει μία θέση (σωζούμε pids[seat_pos] = visitorPID) και αυξάνουμε occupied/active.
Αν γεμίσει το τραπέζι (occupied == CHAIRS_PER_TABLE), το table_full γίνεται 1.
Αν δεν βρει τραπέζι, αφήνει το mutex, κάνει sleep(1) και ξαναπροσπαθεί μέχρι να πετύχει διαθέσιμο τραπέζι ή μέχρι να δει running=0.


6. Παρακολούθηση της Κατάστασης (Monitor)
Ο Monitor διαβάζει περιοδικά (π.χ. κάθε 2 δευτερόλεπτα) τη shared memory και εκτυπώνει:


Την κατάσταση κάθε τραπεζιού (occupied, active, table_full, PIDs).
Με αυτόν τον τρόπο προσφέρει μια «ζωντανή» εικόνα του τι συμβαίνει μέσα στο σύστημα.
Χρησιμοποιείται ένα απλό sleep(...) ανά λούπα για να μην «πλημμυρίζουμε» την κονσόλα, και φυσικά προστατεύουμε την πρόσβαση στη shared memory με sem_wait(sem_mutex) ... sem_post(sem_mutex).

7. Επεκτασιμότητα
Μπορούμε να τροποποιήσουμε τις καθυστερήσεις (π.χ. χρόνο εξυπηρέτησης, χρόνο παραμονής των visitors), διότι έχουν υλοποιηθεί ως παράμετροι που διαβάζονται από argv[].
Ο manager επιτρέπει να διαβάζει κανείς την παράμετρο -v για να ορίσει τον αριθμό των visitors. Έτσι μπορούμε να τεστάρουμε διάφορα σενάρια «φόρτου» (10 visitors, 100 visitors κ.λπ.).
8. Συνοψίζοντας
Ο σχεδιασμός βασίστηκε στις ακόλουθες αρχές:

Καθαρή απομόνωση ρόλων (manager, monitor, receptionist, visitors).
Συγχρονισμός με named semaphores + κοινή μνήμη για τα δεδομένα και τις ουρές παραγγελιών.
Εύκολη διαχείριση τερματισμού μέσω σήματος SIGINT και διαγραφής πόρων (semaphores, shm_unlink κ.λπ.).
Στεγανοποίηση προβλημάτων χρονισμού (race conditions)
Αρκετή ευελιξία στην αλλαγή αριθμού τραπεζιών, visitors κ.λπ.